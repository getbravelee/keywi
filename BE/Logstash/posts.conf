input {
  jdbc {
    jdbc_driver_library => "/Users/isu/elastic/workshop/logstash-8.17.3/lib/mysql-connector-j-8.0.33.jar"
    jdbc_driver_class => "com.mysql.cj.jdbc.Driver"
    jdbc_connection_string => "jdbc:mysql://localhost:3306/keywi"
    jdbc_user => "ssafy"
    jdbc_password => "ssafy"
    schedule => "* * * * *"  # 매 분마다 실행

    statement => "
      SELECT 
        p.post_id,
        p.content,
        p.hashtags,
        p.created_at,
        p.user_id,
        JSON_ARRAYAGG(
          JSON_OBJECT(
            'productId', pr.product_id,
            'name', pr.product_name,
            'description', pr.description,
            'price', pr.price,
            'categoryId', c.category_id,
            'categoryName', c.category_name,
            'parentCategoryId', c.parent_id
          )
        ) AS tagged_products
      FROM posts p
      LEFT JOIN post_product_tag ppt ON p.post_id = ppt.post_id
      LEFT JOIN products pr ON ppt.product_id = pr.product_id
      LEFT JOIN category c ON pr.category_id = c.category_id
      GROUP BY p.post_id
    "
  }
}

filter {
  json {
    source => "hashtags"
    target => "hashtags"
  }

  json {
    source => "tagged_products"
    target => "taggedProducts"
  }

  mutate {
    remove_field => ["tagged_products"] 
  }

  ruby {
    code => "
      # camelCase 매핑
      event.set('postId', event.remove('post_id'))
      event.set('createdAt', event.remove('created_at'))
      event.set('userId', event.remove('user_id'))
      event.remove('tagged_products')
      event.remove('post_id')
      event.remove('created_at')
      event.remove('user_id')

      auto_texts = []
      auto_texts << event.get('content') if event.get('content')

      hashtags = event.get('hashtags')
      if hashtags.is_a?(String)
        begin
          hashtags = JSON.parse(hashtags)
        rescue
          hashtags = []
        end
      end
      auto_texts += hashtags if hashtags.is_a?(Array)

      tagged_products = event.get('taggedProducts')

      if tagged_products.is_a?(Array)
        tagged_products.each do |p|
          auto_texts << p['name'] if p['name']
          auto_texts << p['description'] if p['description']
        end
      end

      auto_texts = auto_texts.map(&:strip).reject(&:empty?).uniq

      # 자동완성용 문장 분리용 ID와 keyword 생성
      auto_texts.each_with_index do |keyword, idx|
        event.clone.tap do |e|
          e.set('keyword', keyword)
          e.set('id', event.get('postId').to_s + '-' + idx.to_s)
          e.set('category', 'post')
        end
      end

      event.set('autocomplete_texts', auto_texts)
    "
  }
}

output {
  stdout { codec => rubydebug }

  elasticsearch {
    hosts => ["http://j12e202.p.ssafy.io:9200"]
    ssl => false
    user => "elastic"
    password => "zldnlWKd!"
    index => "posts"
    document_id => "%{postId}"
  }

  elasticsearch {
    hosts => ["http://j12e202.p.ssafy.io:9200"]
    ssl => false
    user => "elastic"
    password => "zldnlWKd!"
    index => "search_suggest"
    document_id => "%{id}"
    action => "index"
    codec => json
  }
}
